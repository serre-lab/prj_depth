import numpy as np
              #######################################
################## Parameters for stimuli generation  ##################
                #######################################
# Celine Aubuchon 2023 

# These parameters control texture and surface generation/rendering in the stim-generator pipeline. 
# suggested parameters are included here that create a good range in perceieved depth. See 'example_shape.pdf'
# for an example of 1 surface rendered with the different shading and texture qualities.

# Number of Images
num_images = 100000

## Texture Parameters
num_tex_types = 10 # number of texture qualities. Each quality will be refered to by an index (0 = best), which will be used to index into arrays of other parameters.
num_texels=256 # number of texels (polka dots) in the image
rotation_levels = np.ones((num_tex_types,1)) * 180 # best practice is to use random (max 180 deg) rotations for all texture types
min_aspect_levels = np.linspace(1.0, 0.1, num_tex_types) # the min aspect ratio for each texture type (indexed by type)
max_aspect_levels = np.linspace(1.0, 0.4, num_tex_types) # the max aspect ratio for each texture type (indexed by type)
min_size_levels = np.linspace(1.0, 0.4, num_tex_types) # the min size of the texels for each texture type (indexed by type)
texel_size = 3.568 # the diameters of a full sized texel, which is plotted in a 100x100 space and then saved as an image

## Light Parameters
light_levels = 100 # the number of shading qualities. Each quality will be refered to by an index (0 = best), which will be used to index into arrays of other parameters.
ambient_intensity_levels = np.linspace(0.5, 1.0, light_levels) # ambient light for each shading quality, lower ambient light levels create higher constrast shadows (indexed by light level)
light_posns_x = np.zeros((light_levels,1)) # The x postions of the point light for each light quality (indexed by light level)
light_posns_y = np.ones((light_levels,1)) * 3 # the y positions of the point light for each light quality (indexed by light level)
light_posns_z = np.power(np.linspace(6, 10, light_levels, endpoint=True), 2)/8.0 # the z positions (which control how oblique the light is) for each light quality (indexed by light level)

## Surface Parameters
num_surfaces = 100 # number of surfaces 
terrain_size = 10 # size (square length) of the terrain generated by ANT Landscape plug-in
terrain_height = 6 # maximun height (depth) of the surface
noise_depth = 1 # how detailed the noise of the landscape is, lower values create simpler geometries
cloth_subdivs = 50 # how tesselated the 'cloth' is
cloth_size = 7 # the size of the cloth (square length) dropped onto the surface
drop_height = terrain_height + 0.2 # the height at which the cloth is dropped from
last_frame = 50 # how many frames are rendered for the cloth drop

# render properties (CYCLES)
samples=32 # how many samples during rendering
res=64 # square resolution of the image
output_path = ''




